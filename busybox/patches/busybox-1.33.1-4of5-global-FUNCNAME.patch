--- src/shell/ash.c	2021-08-14 11:45:55.267122375 +0200
+++ src.newA/shell/ash.c	2021-08-14 11:36:06.189743230 +0200
@@ -2113,6 +2113,7 @@ static const struct {
 	{ VSTRFIXED|VTEXTFIXED       , defoptindvar, getoptsreset    },
 #endif
 	{ VSTRFIXED|VTEXTFIXED       , NULL /* inited to linenovar */, NULL },
+	{ VSTRFIXED|VTEXTFIXED       , NULL /* inited to funcnamevar */, NULL },
 #if ENABLE_ASH_RANDOM_SUPPORT
 	{ VSTRFIXED|VTEXTFIXED|VUNSET|VDYNAMIC, "RANDOM", change_random },
 #endif
@@ -2139,6 +2140,8 @@ struct globals_var {
 	struct var varinit[ARRAY_SIZE(varinit_data)];
 	int lineno;
 	char linenovar[sizeof("LINENO=") + sizeof(int)*3];
+	char funcnamevar[sizeof("FUNCNAME=") + 256];
+	char *funcname;
 	bool doingtrap;
 };
 extern struct globals_var *BB_GLOBAL_CONST ash_ptr_to_globals_var;
@@ -2150,6 +2153,8 @@ extern struct globals_var *BB_GLOBAL_CON
 #define varinit       (G_var.varinit      )
 #define lineno        (G_var.lineno       )
 #define linenovar     (G_var.linenovar    )
+#define funcnamevar   (G_var.funcnamevar  )
+#define funcname      (G_var.funcname     )
 #define doingtrap	  (G_var.doingtrap    )
 #define vifs      varinit[0]
 #if ENABLE_ASH_MAIL
@@ -2166,13 +2171,14 @@ extern struct globals_var *BB_GLOBAL_CON
 #endif
 #define VAR_OFFSET2 (VAR_OFFSET1 + ENABLE_ASH_GETOPTS)
 #define vlineno   varinit[VAR_OFFSET2 + 5]
+#define vfuncname varinit[VAR_OFFSET2 + 6]
 #if ENABLE_ASH_RANDOM_SUPPORT
-# define vrandom  varinit[VAR_OFFSET2 + 6]
+# define vrandom  varinit[VAR_OFFSET2 + 7]
 #endif
 #define VAR_OFFSET3 (VAR_OFFSET2 + ENABLE_ASH_RANDOM_SUPPORT)
 #if BASH_EPOCH_VARS
-# define vepochs  varinit[VAR_OFFSET3 + 6]
-# define vepochr  varinit[VAR_OFFSET3 + 7]
+# define vepochs  varinit[VAR_OFFSET3 + 7]
+# define vepochr  varinit[VAR_OFFSET3 + 8]
 #endif
 #define INIT_G_var() do { \
 	unsigned i; \
@@ -2183,8 +2189,12 @@ extern struct globals_var *BB_GLOBAL_CON
 		varinit[i].var_text = varinit_data[i].var_text; \
 		varinit[i].var_func = varinit_data[i].var_func; \
 	} \
+	lineno = 0; \
 	strcpy(linenovar, "LINENO="); \
 	vlineno.var_text = linenovar; \
+	strcpy(funcnamevar, "FUNCNAME="); \
+	vfuncname.var_text = funcnamevar; \
+	funcname = NULL; \
 	doingtrap = 0; \
 } while (0)
 
@@ -2325,6 +2335,9 @@ lookupvar(const char *name)
 		if (!(v->flags & VUNSET)) {
 			if (v->var_text == linenovar) {
 				fmtstr(linenovar+7, sizeof(linenovar)-7, "%d", lineno);
+			} else
+			if (v->var_text == funcnamevar) {
+				fmtstr(funcnamevar+9, sizeof(funcnamevar)-9, "%s", funcname);
 			}
 			return var_end(v->var_text);
 		}
@@ -9076,7 +9089,7 @@ defun(union node *func)
 static smallint evalskip;       /* set to SKIPxxx if we are skipping commands */
 static int skipcount;           /* number of levels to skip */
 static int loopnest;            /* current loop nesting level */
-static int funcline;            /* starting line number of current function, or 0 if not in a function */
+static int funcline = 0;        /* starting line number of current function, or 0 if not in a function */
 
 /* Forward decl way out to parsing code - dotrap needs it */
 static int evalstring(char *s, int flags);
@@ -9731,9 +9744,11 @@ evalfun(struct funcnode *func, int argc,
 	struct jmploc jmploc;
 	int e;
 	int savefuncline;
+	char *savefuncname;
 
 	saveparam = shellparam;
 	savefuncline = funcline;
+	savefuncname = funcname;
 	savehandler = exception_handler;
 	e = setjmp(jmploc.loc);
 	if (e) {
@@ -9743,6 +9758,7 @@ evalfun(struct funcnode *func, int argc,
 	exception_handler = &jmploc;
 	shellparam.malloced = 0;
 	func->count++;
+	funcname = strdup(func->n.ndefun.text);
 	funcline = func->n.ndefun.linno;
 	INT_ON;
 	shellparam.nparam = argc - 1;
@@ -9754,6 +9770,9 @@ evalfun(struct funcnode *func, int argc,
 	evaltree(func->n.ndefun.body, flags & EV_TESTED);
  funcdone:
 	INT_OFF;
+	if(funcname)
+		free(funcname);
+	funcname = savefuncname;
 	funcline = savefuncline;
 	freefunc(func);
 	freeparam(&shellparam);
